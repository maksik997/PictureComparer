package pl.magzik.algorithms;

import org.jetbrains.annotations.NotNull;
import pl.magzik.algorithms.math.DCT;
import pl.magzik.cache.AdaptiveCache;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.util.*;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * Implementation of the {@link Algorithm} interface that computes perceptual hashes for images.
 * <p>
 * This algorithm is used to generate perceptual hashes for images in order to group similar images together.
 * It performs the following steps for each image in the input set:
 * </p>
 * <ol>
 *     <li><strong>Resize:</strong> Each image is resized to a fixed size of 8x8 pixels to standardize the input.</li>
 *     <li><strong>Extract Sample:</strong> Each pixel value in the resized image is extracted into a matrix.</li>
 *     <li><strong>Discrete Cosine Transform (DCT):</strong> The DCT is applied to the image matrix to reduce high-frequency components.</li>
 *     <li><strong>Generate Hash:</strong> A hash is generated by comparing each pixel with the average value of the matrix. Pixels with values above the average are marked as '1', and those below the average as '0'.</li>
 *     <li><strong>Group by Hash:</strong> Images are grouped by their perceptual hash, and images with the same hash are considered similar and placed in the same group.</li>
 * </ol>
 * <p>
 * Images are then grouped based on their hashes, and the result is returned as a map where each key represents a unique hash,
 * and the corresponding value is a set of images that share that hash.
 * </p>
 */
public class PerceptualHash implements Algorithm<String> {

    private static final int WIDTH = 8, HEIGHT = 8;

    @Override
    public Map<String, Set<File>> apply(@NotNull Set<File> group) {
        List<File> gf = group.stream().toList();
        List<String> hashes = group.stream()
                                    .map(this::resize)
                                    .map(this::extractSample)
                                    .map(DCT::apply)
                                    .map(this::buildHash)
                                    .toList();

        if (hashes.stream().anyMatch(Objects::isNull))
            throw new NullPointerException("Some hashes are null.");

        return IntStream.range(0, gf.size())
            .boxed()
            .collect(Collectors.groupingBy(
                hashes::get,
                Collectors.mapping(gf::get, Collectors.toList())
            )).entrySet().stream()
            .collect(Collectors.toMap(Map.Entry::getKey, e -> new HashSet<>(e.getValue())));
    }

    /**
     * Resizes an image file to a fixed size of 8x8 pixels.
     *
     * <p>
     * The image is resized to a smaller 8x8 dimension in grayscale format to reduce the amount of detail
     * and prepare it for hashing.
     * </p>
     *
     * @param file The image file to be resized.
     * @return The resized {@link BufferedImage} in grayscale.
     * @throws UncheckedIOException If an IOException occurs while retrieving the image.
     */
    @NotNull
    private BufferedImage resize(@NotNull File file) {
        BufferedImage image;
        try {
            image = AdaptiveCache.getInstance().get(file);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }

        BufferedImage resizedImage = new BufferedImage(WIDTH, HEIGHT, BufferedImage.TYPE_BYTE_GRAY);
        Graphics2D g = resizedImage.createGraphics();
        g.drawImage(image, 0, 0, WIDTH, HEIGHT, null);
        g.dispose();
        return resizedImage;
    }

    /**
     * Extracts the pixel values from a resized image into a matrix.
     *
     * <p>
     * The image is represented as a 2D array where each element corresponds to a pixel's value.
     * </p>
     *
     * @param image The resized image to be sampled.
     * @return A 2D array representing the pixel values of the image.
     */
    private double[][] extractSample(BufferedImage image) {
        double[][] sample = new double[WIDTH][HEIGHT];
        for (int x = 0; x < WIDTH; x++) {
            for (int y = 0; y < HEIGHT; y++) {
                sample[x][y] = image.getRaster().getSampleDouble(x, y, 0);
            }
        }
        return sample;
    }

    /**
     * Builds a perceptual hash from the image sample matrix.
     *
     * <p>
     * This method compares each pixel's value with the average pixel value of the matrix.
     * If a pixel's value is greater than the average, it is marked as '1'; otherwise, '0'.
     * The resulting hash is a binary string of '1's and '0's.
     * </p>
     *
     * @param matrix The matrix of pixel values extracted from the image.
     * @return The generated perceptual hash as a binary string.
     */
    private String buildHash(double[][] matrix) {
        double avg = getAvg(matrix);
        return Arrays.stream(matrix)
                .flatMapToDouble(Arrays::stream)
                .mapToObj(value -> value > avg ? "1" : "0")
                .collect(Collectors.joining());
    }

    /**
     * Computes the average pixel value of the matrix.
     *
     * @param matrix The matrix of pixel values.
     * @return The average pixel value of the matrix.
     */
    private double getAvg(double[][] matrix) {
        return Arrays.stream(matrix)
                .flatMapToDouble(Arrays::stream)
                .average()
                .orElse(0.0);
    }
}
